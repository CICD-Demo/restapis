= Adding a full-text search engine
:Author: Emmanuel Bernard <emmanuel@hibernate.org>

== What will you learn here?

You have a functional TicketMonster but the ability to find the right ticket is a bit limited. You would like to add a search engine to make show discovery much easier. In this tutorial, you will learn how to:

* Add Hibernate Search to your web application
* Index your entities and build the search engine to retrieve your data
* Add faceting i.e. the ability to filter results by price range, categories etc
* Offer the ability to search around the user's location (geolocation or spatial search)

[NOTE]
.What is Hibernate Search?
====
Hibernate Search indexes objects into Lucene, a full-text search engine and offer an object-oriented API to query those objects using full-text search, spatial queries and more.

It integrates transparently with Hibernate ORM by listening to entity changes and updating the Lucene index accordingly.

Finally Hibernate Search implements several strategies to cluster indexes very easily.
====

== Setting up the infrastructure

We just need to add Hibernate Search in our classpath and add a few configuration options in `persistence.xml`.

Our first task is to add Hibernate Search as a dependency to our application. There are two ways to do it. For now we will use the JBoss Modules approach where Hibernate Search is installed on JBoss EAP or WildFly.

=== Set up the dependencies

Download the https://downloads.sourceforge.net/project/hibernate/hibernate-search/4.3.0.CR1/hibernate-search-modules-4.3.0.CR1-jbossas-72-dist.zip[Hibernate Search module] and copy its content into JBoss EAP or WildFly's `modules` directory.

Next update `jboss-deployment-structure.xml` to include the ORM module of Hibernate Search. This module is necessary to import the Hibernate Search engine as well as the integration code with Hibernate ORM.

.src/main/webapp/WEB_INF/jboss-deployment-structure.xml
[source,xml]
----
<jboss-deployment-structure>
    <deployment>
        <exclusions>
        </exclusions>
        <!-- This allows you to define additional dependencies, it is the same
             as using the Dependencies: manifest attribute -->
        <dependencies>
            <module name="org.jboss.as.naming" />
            <module name="org.jboss.as.server" />
            <module name="org.jboss.msc" />
            <module name="org.hibernate.search.orm" services="export" />
        </dependencies>
    </deployment>
</jboss-deployment-structure>
----

NOTE: `services="export"` lets Hibernate Search use the service locator pattern to integrate with Hibernate ORM

Finally, we need to add Hibernate Search as a `provided` dependency in our `pom.xml`.

.pom.xml
[source,xml]
----
<project ...>
    ...
    <dependencies>
        <!-- Add Hibernate Search as a dependency -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-search-orm</artifactId>
            <version>4.3.0.Final</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-search-engine</artifactId>
            <version>4.3.0.Final</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-search-analyzers</artifactId>
            <version>4.3.0.Final</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
  ...
</project>
----

=== Add some configuration

Hibernate Search needs a few extra settings in `persistence.xml`. You can store the indexes either in RAM or on the file system. We will start with an in-memory storage to keep things simple.

.src/main/resources/META-INF/persistence.xml
[source,xml]
----
<persistence ...>
     <persistence-unit name="primary">
         ...
         <properties>
             ...
             <property name="hibernate.search.default.directory_provider" value="ram"/>

             <!-- Alternatively store the index on the file system
             <property name="hibernate.search.default.directory_provider" value="filesystem"/>
             <property name="hibernate.search.default.indexBase" value="/var/data/ticket-monster/indexes"/>
             -->
         </properties>
    </persistence-unit>
</persistence>
----


=== Add some utilities

CAUTION: Need to fix the `@Inject` issue before filling up that section

== Build the core search engine

We are now ready to start our search engine. Let's first see how we decide what to index before building the right queries.

=== Indexing the domain model

Marking entities and properties as indexed is as simple as adding annotations. But we need to properly understand the kind of queries we wish to build. We want our users to be able to search for:

* a given `Event` by name and description
* at a given `Venue` by name and possibly by location
* filtering by category, price and date would be nice too

==== Adding the metadata to our domain model

You cannot do joins in a full-text index. Instead, we cheat by denormalizing the information and indexing the associated objects we want to query by in the same entry. For that we need to be able to navigate to all of the entities we are interested in.

Let's look at our domain model.

[[database-design]]
.Entity-Relationship Diagram
image::gfx/database-design.png[scaledwidth="70%"]

CAUTION: TODO: fix diagram around TicketPriceCategory

`Show` happens to be the central entity from which we can reach `Event`, `Venue` as well as price and date information for each `Performance`. That will be the entity we will start indexing from.

Let make `Show` indexed by adding an `@Indexed` annotation. We also want to index the associated `Event` and `Venue` when a given `Show` is indexed. For that, we will mark each association as `@IndexedEmbedded`.

.src/main/java/org/jboss/jdf/example/ticketmonster/model/Show.java
[source,java]
----
...

@SuppressWarnings("serial")
@Entity
@Table(uniqueConstraints = @UniqueConstraint(columnNames = { "event_id", "venue_id" }))
@Portable
@Indexed
public class Show implements Serializable {

    /* Declaration of fields */

    /**
     * The synthetic id of the object.
     */
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Long id;

    /**
     * <p>
     * The event of which this show is an instance. The <code>@ManyToOne<code> JPA mapping establishes this relationship.
     * </p>
     * 
     * <p>
     * The <code>@NotNull</code> Bean Validation constraint means that the event must be specified.
     * </p>
     */
    @ManyToOne
    @NotNull
    @IndexedEmbedded
    private Event event;

    /**
     * <p>
     * The venue where this show takes place. The <code>@ManyToOne<code> JPA mapping establishes this relationship.
     * </p>
     * 
     * <p>
     * The <code>@NotNull</code> Bean Validation constraint means that the venue must be specified.
     * </p>
     */
    @ManyToOne
    @NotNull
    @IndexedEmbedded
    private Venue venue;

    ...
}
----

Next, we need to index the `Event` name and description. To make a property as indexed, use the `@Field` annotation.

.src/main/java/org/jboss/jdf/example/ticketmonster/model/Event.java
[source,java]
----
...

@SuppressWarnings("serial")
@Entity
@Portable
public class Event implements Serializable {

    ...

    @Column(unique = true)
    @NotNull
    @Size(min = 5, max = 50, message = "An event's name must contain between 5 and 50 characters")
    @Field
    private String name;

    ...

    @NotNull @Size(min = 20, max = 1000, message = "An event's description must contain between 20 and 1000 characters") @Field private String description;

    ...
}
----

[NOTE]
.What's in a name?
====
By default, each entity type is indexed in a dedicated Apache Lucene _index_. An index is made of a set of _documents_. Each document contains _fields_ which are made of a name and a value. You can think of a document as a `Map<String,String>`. Of course the structure of the index is vastly different to make searches fast.

Now you understand where `@Indexed` and `@Field` come from.
====

Do the same for `Venue` and mark the `name` attribute as `@Field`. Now when a `Show` is created or modified, the index will be updated and will contain the show's event name and description as well as the venue name. But what about existing shows in our database? How can we index them?

==== Indexing existing data

For initial indexing (or reindexing), Hibernate Search offers an API: `MassIndexer`. It reindexes all entities of a given type quickly. We are creating a service that will reindex our data when the application starts. That is convenient during development time.

.src/main/java/org/jboss/jdf/example/ticketmonster/service/Bootstrap.java
[source,java]
----
@Singleton
@Startup
public class Bootstrap {
    @Inject private EntityManager em;
    @Inject private Logger logger; 

    @PostConstruct
    public void onStartup() {
        try {
            logger.info("Indexing entities");
            FullTextEntityManager ftem = Search.getFullTextEntityManager(em);
            ftem.createIndexer().purgeAllOnStart(true).startAndWait();
        } catch (InterruptedException e) {
            logger.severe("Unable to index data with Hibernate Search");
        }
    }
}
----

The Hibernate Search APIs are accessible via `FullTextEntityManager`, a simpler wrapper around the `EntityManager` you are used to deal with. The `MassIndexer` API is a fluent API letting you refine what entities you want to reindex, with how many threads, synchronously or asynchronously etc. But the simple usage is good enough for most cases.

We now have indexed entities, it is time to write our query engine.

=== Writing the search engine

Since the application makes use of rich clients, we will expose our search service via a REST endpoint. We will retrieve a `FullTextEntityManager` - the entry point for Hibernate Search.

.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
[source,java]
----
@Stateless
@Path("/search")
public class SearchService {
    @Inject
    EntityManager em;
    @Inject
    Logger logger;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString) {
        FullTextEntityManager ftem = Search.getFullTextEntityManager(em);
        return null;
    }
}
----

.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/ShowResults.java
[source,java]
----
public class ShowResults {
    private List<ShowView> results;

    public ShowResults(List<ShowView> results) {
        this.results = results;
    }
    

    public List<ShowView> getResults() {
        return results;
    }
}
----

.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/ShowView.java
[source,java]
----
public class ShowView {
    private Long eventId;
    private String eventName;
    private String eventDescription;
    private String eventCategory;
    private String venueName;

    public ShowView(Show show) {
        this.eventId = show.getEvent().getId();
        this.eventName = show.getEvent().getName();
        this.eventDescription = show.getEvent().getDescription();
        this.eventCategory = show.getEvent().getCategory().getDescription();
        this.venueName = show.getVenue().getName();
    }

    public Long getEventId() {
        return eventId;
    }

    public String getEventName() {
        return eventName;
    }

    public String getEventDescription() {
        return eventDescription;
    }

    public String getEventCategory() {
        return eventCategory;
    }

    public String getVenueName() {
        return venueName;
    }
}
----

We could have returned a list of `Show` to our endpoint but since `Show` is linked to many other entities, we will instead return a list of `ShowView` only containing the relevant information. We will save bandwidth, database load and increase responsiveness.
We could also return a simple list of `ShowView` but preparing for the future extension of our search engine, we will wrap than list in a `ShowResults` object.

Writing a full-text query is composed of a few phases:

* build an Apache Lucene query
* build an object query wrapping the Lucene query
* execute the query

==== Build the Apache Lucene query

Our first step is to write the core full-text query. We will use Hibernate Search query DSL for this. Every query starts from a `QueryBuilder` for a given entity type. From a `QueryBuilder` we can define a specific query (keyword, phrase, range etc), on one or several fields and a few options (boost, fuziness etc).

By default, a property annotated `@Field` has a corresponding field named after the property. When embedding associations in the index, you can use the usual dot notation: starting from a `Show`, you can look for the event name via the following path `event.name`.

Here we will focus on keyword queries - queries looking for specific terms - on a few fields of event and venue. Since a matching term on an event name seems more important than on an event description, we use different boost time to give them different weight in the ranking system. And if the query string is empty, we will return all elements.

.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
[source,java]
----
...

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString) {
        FullTextEntityManager ftem = Search.getFullTextEntityManager(em);

        QueryBuilder qb = ftem.getSearchFactory()
                            .buildQueryBuilder()
                            .forEntity(Show.class)
                            .get();
        Query luceneQuery = buildLuceneQuery(searchString, qb);

        ...
    }

    private Query buildLuceneQuery(String searchString, QueryBuilder qb) {
        Query luceneQuery;
        if (searchString.isEmpty()) {
            // Return all terms
            luceneQuery = qb.all().createQuery();
        }
        else {
            // Find the terms of searchString with terms in event.name (weight of 10),
            // event.description (weight of 1) and venue.name (weight of 3)
            luceneQuery = qb
                .keyword()
                .onField("event.name").boostedTo(10f)
                .andField("event.description")
                .andField("venue.name").boostedTo(5f)
                .matching(searchString)
                .createQuery();
        }
        return luceneQuery;
    }

...
----

[NOTE]
.Different ways to write a Lucene query
====
There are several ways to express the core of your full-text query:

* native Lucene query APIs
* Lucene query parser
* Hibernate Search query DSL

The Hibernate Search query DSL has several advantages:

* it is easy to use, easier to write
* it offers a great deal of query expressiveness
* it generates raw Lucene queries that can be combined
* it is at the domain object level (not the index level) and thus deals with analyzers and property value conversion transparently
====

Next we need to wrap that query into the Hibernate Search full-text query.

==== Build the object query

Hibernate ORM offers several ways of querying your database (JP-QL, native SQL queries, criteria query). Think of Hibernate Search full-text queries as another approach. Even the API is similar and interchangeable. Objects returned by Hibernate Search queries are managed objects just like object returned by a JP-QL query.

The object query is created from the `FullTextEntityManager.createFullTextQuery()` passing the Lucene query and the (list of) entity type we are interested in. Our query would return a list of `Show` out of the box, but we really want a list of `ShowResult`. To do that, we use an Hibernate ORM `ResultTransformer` and apply it to the query.

.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
[source,java]
----
...

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString) {
        FullTextEntityManager ftem = Search.getFullTextEntityManager(em);
        QueryBuilder qb = ftem.getSearchFactory()
                            .buildQueryBuilder()
                            .forEntity(Show.class)
                            .get();

        Query luceneQuery = buildLuceneQuery(searchString, qb);

        FullTextQuery objectQuery = ftem.createFullTextQuery(luceneQuery, Show.class);
        objectQuery.setResultTransformer(ShowViewResultTransformer.INSTANCE);

        List<ShowResult> results = (List<ShowResult>) objectQuery.getResultList();
        return new ShowResults(results);
    }

    private Query buildLuceneQuery(String searchString, QueryBuilder qb) {
        Query luceneQuery;
        if (searchString.isEmpty()) {
            // Return all terms
            luceneQuery = qb.all().createQuery();
        }
        else {
            // Find the terms of searchString with terms in event.name (weight of 10),
            // event.description (weight of 1) and venue.name (weight of 3)
            luceneQuery = qb
                .keyword()
                .onField("event.name").boostedTo(10f)
                .andField("event.description")
                .andField("venue.name").boostedTo(5f)
                .matching(searchString)
                .createQuery();
        }
        return luceneQuery;
    }
----


.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/ShowViewResultTransformer.java
[source,java]
----
/**
 * Converts a list of Show into a list of ShowView.
 * 
 * @author Emmanuel Bernard
 */
public class ShowViewResultTransformer implements ResultTransformer {
    public static ShowViewResultTransformer INSTANCE = new ShowViewResultTransformer();

    @Override
    public Object transformTuple(Object[] tuple, String[] aliases) {
        return tuple;
    }

    @Override
    public List transformList(List collection) {
        List<ShowView> results = new ArrayList<ShowView>(collection.size());
        for (Show show : (List<Show>) collection) {
            results.add(new ShowView(show));
        }
        return results;
    }
}
----

That's it! We have a fully functional search engine. Now it is time to expose it to our user.

[NOTE]
.What's in a query?
====
A `FullTextQuery` is literally a subclass of the JPA `Query` class. You have access to all of its capability, in particular pagination!

It also offers additional methods. To name a few:

* `getResultSize()`: get the number of matching elements (regardless of pagination) ; this operation is very efficient.
* `getSort()`: sort results explicitly instead of by relevance.
* `setProjection()`: return projected fields instead of managed entities ; this does not hit the database at all.
====

=== Exposing search to the UI

We have seen previously in this tutorial how to write the UI part of a backbone.js application. So this section will go a tiny bit faster and give you the end result.

Let's first define a model for the results we will receive from the search REST endpoint. This model will also be responsible for computing the application URL exposed for bookmarkability.

[source,javascript]
.src/main/webapp/resources/js/app/models/results.js
----
/**
 * Module for the query results model
 */
define([ 
    'configuration',
    'backbone'
], function (config) {
    /**
     * The Results model class definition
     */
    var Results = Backbone.Model.extend({
        urlRoot: config.baseUrl + 'rest/search', // the URL for performing CRUD operations
        initialize  : function() {
            _.bindAll(this,"fetch");
            _.bindAll(this,"appUrl");
        },

        // the URL with params to reach the REST endpoint
        url: function() {
            params = '?query=' + encodeURIComponent(this.get("query"));
            return this.urlRoot + params;
        },

        // the application URL as exposed by the application for bookmarkability
        appUrl: function() {
            result = "search/anywhere/";
            var query = this.get("query");
            result += encodeURIComponent(query);
            return result;
        }
    });

    // export the Results class
    return Results;
});
----

Now that we have a model bound to our backend, we need a view to expose the results to the user.

[source, javascript]
.src/main/webapp/resources/js/app/views/results.js
----
define([
    'utilities',
    'require',
    'text!../../../../templates/desktop/results.html',
    'configuration',
    'bootstrap'
], function (
    utilities,
    require,
    resultsTemplate,
    config,
    Bootstrap) {
    
    var ResultsView  = Backbone.View.extend({

        events:{
        },
        
        initialize:function () {
            this.model.bind('change', this.render, this);
        },
        
        render:function () {
            $(this.el).empty();
            this.delegateEvents();
            utilities.applyTemplate($(this.el), resultsTemplate, {model:this.model, query:this.model.get("query")});
            return this;
        }
    });
    return ResultsView;
});
----

[source, html]
.src/main/webapp/resources/templates/desktop/results.html
----
<h3 class="page-header light-font special-title">Results for <%=query%></h3>
<div class="row-fluid">
    <div class='span12'>
        <table class='table table-bordered' style="background: #fffffa;">
            <thead>
            <tr>
                <th>Event</th>
                <th>Venue</th>
            </tr>
            </thead>
            <tbody id='bookingList'>
            <% _.each(model.get("results"), function (result) { %>
            <tr>
                <td><a href="#events/<%=result.eventId%>"><%=result.eventName%></a></td>
                <td><%=result.venueName%></td>
            </tr>
            <% }); %>
            </tbody>
        </table>
    </div>
</div>
----

Note that we do retrieve the actual query from the model (`query` parameter) and pass it to the template for display. We will need to fill `query` from the router. Speaking of the devil, let's add the necessary routes to trigger a query.

[source, javascript]
.src/main/webapp/resources/js/app/router/desktop/router.js
----
...
define("router", [
    ...,
    'app/models/results',
    ...,
    'app/views/desktop/results',
    'text!../templates/desktop/main.html'
],function ($,
            ...,
            Results,
            ...,
            ResultsView,
            MainTemplate) {

    ...

    var Router = Backbone.Router.extend({
        routes:{
            ...,
            "search/anywhere/:query":"results",
            ...
        },
        ...,
        results:function (query) {
            var model = new Results();
            model.set("query", decodeURIComponent(query));
            var resultsView = new ResultsView({model:model, el:$("#content"), router:this});
            model.bind("change",
                function () {
                    utilities.viewManager.showView(resultsView);
                }).fetch();
        }
    });

    ...

    return router;
});
----

We need to do one that thing. Somehow the query URL (e.g. `#search/anywhere/morrison`) needs to be called. Let's add a search box in the top menu and have it call that URL.

[source, html]
.src/main/webapp/resources/templates/desktop/main.html
----
...
                    <ul class="nav">
                        <li><a href="#about">About</a></li>
                        <li><a href="#events">Events</a></li>
                        <li><a href="#venues">Venues</a></li>
                        <li><a href="#bookings">Bookings</a></li>
                        <li><a href="booking-monitor.html">Monitor</a></li>
                        <li><a href="admin">Administration</a></li>
                    </ul>
                    <script type="text/javascript">
                      //<![CDATA[
                        function get_results(event)
                        {
                            event.preventDefault();
                            location.href = "#search/anywhere/" + escape(document.searchbox.query.value);
                            return false;
                        }
                      //]]>
                    </script>
                    <form id="searchbox" name="searchbox" class="navbar-search pull-right" onsubmit="return get_results(event)">
                        <input id="query" name="query" class="search-query" type="text" placeholder="Search"/>
                    </form>
...
----

This concludes our work to get the core search engine built and exposed via the UI.

Our next step is to improve the search results by offering the ability to filter results by the user's location.

== Filter results by location

Let's face it, driving more than 50 kilometers to go to an event is quite uncommon. We will offer the ability to filter results to venues within a given radius and luckily for us, Hibernate Search offer such functionality very easily. Let's first work on the backend from the REST endpoint down to the actual Hibernate Search query. But first, let's make sure we index the geographical position of a venue.

Coordinates are provided as doubles representing the latitude and longitude hosted on the `Address` object associated with a venue. To make sure it is indexed, we need to add a spatial index field, link it to the coordinate properties and make sure `Address` is indexed when `Venue` is. `@Spatial` is the annotation describing a spatial field while `@Latitude` and `@Longitude` link properties to a spatial field.

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/model/Venue.java
----
@SuppressWarnings("serial")
@Entity
@Portable
public class Venue implements Serializable {
    ...

    /**
     * The address of the venue
     */
    @IndexedEmbedded
    private Address address = new Address();

    ...
}
----

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/model/Address.java
----
@SuppressWarnings("serial")
@Embeddable
@Portable
@Spatial(name="coordinates", spatialMode=SpatialMode.GRID)
public class Address implements Serializable {

    /* Declaration of fields */
    private String street;
    private String city;
    private String country;
    @Latitude(of="coordinates")
    private double latitude;
    @Longitude(of="coordinates")
    private double longitude;
    
    ...
}
----

The `@Spatial` field is named `coordinates` and the name is used to match the corresponding `@Latitude` and `@Longitude`.

[NOTE]
.Types of spatial indexes
====
You can index and query spatial data in two fashions:

* by indexing latitude and longitude and do two range queries - `SpatialMode.RANGE`
* by using a grid index which translates latitude and longitude into a grid number and use a simple term query - `SpatialMode.GRID`

The former is fine as long as you have less than 100k point of interests. The latter will scale better but take a bit more space in your index. You can get more information from the Hibernate Search documentation.
====

Now that the location is indexed, let's receive the user location from the REST endpoint and adjust our Hibernate Search query to restrict results to a specific area. The Hibernate Search query DSL offers the tools to write the gelocalize queries as well as the ability to compose bits of queries together.

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
----
@Stateless
@Path("/search")
public class SearchService {

    ...

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString, 
        @QueryParam("latitude") Double latitude, @QueryParam("longitude") Double longitude) {

        ...
        
        Query luceneQuery = buildLuceneQuery(searchString, latitude, longitude, qb);

        ...

    }

    private Query buildLuceneQuery(String searchString, Double latitude, Double longitude, QueryBuilder qb) {
        Query luceneQuery;
        Query termsQuery;
        if (searchString.isEmpty()) {
            // Return all terms
            termsQuery = qb.all().createQuery();
        }
        else {
            // Find the terms of searchString with terms in event.name (weight of 10),
            // event.description (weight of 1) and venue.name (weight of 3)
             termsQuery = qb.keyword()
                .onField("event.name").boostedTo(10f)
                .andField("event.description")
                .andField("venue.name").boostedTo(5f)
                .matching(searchString)
                .createQuery();
        }
        if (latitude != null && longitude != null) {
            Query localQuery = qb.spatial()
                .onCoordinates("venue.address.coordinates")
                .within(50, Unit.KM)
                .ofLatitude(latitude).andLongitude(longitude)
                .createQuery();
            luceneQuery = qb.bool()
                .must(termsQuery)
                .must(localQuery)
                .createQuery();
        }
        else {
            luceneQuery = termsQuery;
        }
        return luceneQuery;
    }

}
----

Only the lucene query has changed, the rest of the code remains as it is. If `latitude` and `longitude` are provided, we create a `localQuery` which restricts results to 50 kilometers of the provided coordinates and we use the field hosted on the venue address. The next step is to combine this local query with the term query previously build thanks to a boolean query.

Let's retrieve the latitude and longitude from the user's browser and pass it along to our REST service.

[source,javascript]
.src/main/webapp/resources/js/app/models/results.js
----
        ...

        // the URL with params to reach the REST endpoint
        url: function() {
            params = '?query=' + encodeURIComponent(this.get("query"));
            if (typeof this.get("lat") != 'undefined' && typeof this.get("lng") != 'undefined') {
                params = params + '&latitude=' + encodeURIComponent(this.get("lat")) + '&longitude=' + encodeURIComponent(this.get("lng"));
            }
            return this.urlRoot + params;
        },

        // the application URL as exposed by the application for bookmarkability
        appUrl: function() {
            result = "search/";
            var query = this.get("query");
            var lat = this.get("lat");
            var lng = this.get("lng");
            if (typeof lat != 'undefined' && typeof lng != 'undefined') {
                result += "around/" + lat + "/" + lng + "/";
            }
            else {
                result += "anywhere/";
            }
            result += encodeURIComponent(query);
            return result;
        }

        ...
----

The `url` function is the URL that calls the REST endpoint while the `appUrl` function is the bookmarkable URL as displayed by the application for a search:

* `search/anywhere/morisson` looks for events all around the world mentioning morisson
* `search/around/48.8534100/2.3488000/morisson` looks for events around Paris mentioning morisson

Let's add the necessary route corresponding to the local search. The router also needs to set in the model the `lat` and `lng` attributes used by the URL builder methods above.

[source, javascript]
.src/main/webapp/resources/js/app/router/desktop/router.js
----
    ...

    var Router = Backbone.Router.extend({
        routes:{
            ...,
            "search/anywhere/:query":"results",
            "search/around/:lat/:lng/:query":"localResults",
            ...
        },
        ...,
        results:function (query, categoryId, minPriceId) {
            this.localResults(null, null, query);
        },
        localResults:function (lat, lng, query) {
            var model = new Results();
            model.set("query", decodeURIComponent(query));
            if (lat != null) {
                model.set("lat", lat);
            }
            if (lng != null) {
                model.set("lng", lng);
            }
            var resultsView = new ResultsView({model:model, el:$("#content"), router:this});
            model.bind("change",
                function () {
                    utilities.viewManager.showView(resultsView);
                }).fetch();
        }

    ...
----

Finally let's retrieve the user coordinates from the user's browser and use it in our queries if the user ticks the "around me" checkbox. This is fairly easy and standard to do in JavaScript. The example here is a bit verbose as we made sure to have proper fallback to a generic query if the browser does not give us the coordinates (inability to find them, user does not accept to be geolocalized, etc.).

[source, html]
.src/main/webapp/resources/templates/desktop/main.html
----
...
                    <ul class="nav">
                        <li><a href="#about">About</a></li>
                        <li><a href="#events">Events</a></li>
                        <li><a href="#venues">Venues</a></li>
                        <li><a href="#bookings">Bookings</a></li>
                        <li><a href="booking-monitor.html">Monitor</a></li>
                        <li><a href="admin">Administration</a></li>
                    </ul>
                    <script type="text/javascript">
                      //<![CDATA[
                        function get_results(event)
                        {
                            event.preventDefault();
                            if (document.searchbox.local.checked && navigator.geolocation)
                            {
                                options = {
                                    maximumAge: 6000000 // milliseconds (100 minutes)
                                }
                                navigator.geolocation.getCurrentPosition(handlePosition, handleError, options);
                                return false;
                            }
                            else {
                                return queryAnywhere();
                            }
                            function handlePosition(pos)
                            {
                                return queryLocal(pos.coords);
                            }
                            function handleError(error)
                            {
                                return queryAnywhere();
                            }
                        }
                        function queryAnywhere()
                        {
                            location.href = "#search/anywhere/" + escape(document.searchbox.query.value);
                            return false;
                        }
                        function queryLocal(coords)
                        {
                            location.href = "#search/around/" + coords.latitude + '/' + coords.longitude + '/' + escape(document.searchbox.query.value);
                            return false;
                        }
                      //]]>
                    </script>
                    <form id="searchbox" name="searchbox" class="navbar-search pull-right" onsubmit="return get_results(event)">
                        <input id="query" name="query" class="search-query" type="text" placeholder="Search"/>
                        <input name="local" type="checkbox">around me</input>
                    </form>
...
----

== Enable and expose navigation by facets

This feature is by far the most complex to add but brings a significant boost to usability. The user will be able to refine a query with facets automatically computed and suggested. In practice, it helps a user to refine a query to find what he was looking for.

[NOTE]
.What is a facet
====
Faceting offers a way to categorize the results of a query based on selected dimensions:

* by price range
* by average comment notes
* by brand
* ...

A facet is a given brand, a given price range and each facet can display the number of matching results.
====

In our case, we want to see our results:

* by category (concert, etc)
* by minimum price range

Let's split our work in a few steps:

* indexing the necessary data
* create the faceting requests
* return the list of facets for the UI to expose them
* upon user selection further filter results by a given facet

=== Indexing data for faceting

A facet is aggregated by its exact value so no string tokenization should take place. By default, strings are _analyzed_ and split into tokens often corresponding to individual words. For a field used in faceting, we need to disable the analyzing phase. Let's do that for the category description.

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/model/EventCategory.java
----
...
@SuppressWarnings("serial")
@Entity
@Portable
public class EventCategory implements Serializable {

    ...

    @Column(unique=true)
    @NotEmpty
    @Field(analyze=Analyze.NO)
    private String description;

    ....
}
----

Also add `@IndexedEmbedded` on `Event.category`.

Next, we want to index the minimum price for a given `Show`. Since shows only contain a set of `TicketPrice`, we need to apply some transformation before indexing the information. Hibernate Search's field bridges are exactly that. They take a property and let you freely decide how the data in ultimately indexed. In our case, we will take the set of prices, find the minimum price and index it. A field bridge is declared with a `@FieldBridge` annotation. Since our field is not represented bu the object model, we will give it an artificial name: `ticketPrices.min`. We will use this to later query it.

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/model/Show.java
----
    ...

    @OneToMany(mappedBy = "show", cascade = ALL, fetch = EAGER)
    @Field(name="ticketPrices.min", analyze=Analyze.NO,
        bridge=@FieldBridge(impl=PriceMinBridge.class))
    private Set<TicketPrice> ticketPrices = new HashSet<TicketPrice>();

    ...
----

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/model/search/PriceMinBridge.java
----
/**
 * Find the minimum price for a give show and index it.
 * 
 * @author Emmanuel Bernard <emmanuel@hibernate.org>
 */
public class PriceMinBridge extends NumericFieldBridge {

    @Override
    public Object get(String name, Document document) {
        return Float.valueOf( document.getFieldable( name ).stringValue() );
    }
    
    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        if (value != null) {
            float min = Float.MAX_VALUE;
            for (TicketPrice price : (Set<TicketPrice>) value) {
                float current = price.getPrice();
                if (current < min) {
                    min = current;
                }
            }
            luceneOptions.addNumericFieldToDocument(name, min, document);
        }
    }
}
----

Since we want to store a numerical value, we did extend `NumericFieldBridge`. Check out the Hibernate Search documentation for more details on field bridges.

Now is the time to look at our query.

=== Create the faceting requests

Expressing the faceting requests is easy. We will use the query DSL to create a faceting request for each facet group, and then associate each faceting request to the Hibernate Search query.

Faceting groups can be of two types:

* discrete: each value found for a given field are considered a facet value
* range: a pre-defined set of ranges are created and results are broken down by them

You can refine facet groups a bit, for example:

* should facets with no results be returned nevertheless
* how facets should be ordered by facet group (by field value, by range definition etc)

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
----
    ...

    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString, 
        @QueryParam("latitude") Double latitude, @QueryParam("longitude") Double longitude) {

        ...
        
        Query luceneQuery = buildLuceneQuery(searchString, latitude, longitude, qb);
        FullTextQuery objectQuery = ftem.createFullTextQuery(luceneQuery, Show.class);
        
        enableFaceting(qb, objectQuery);
        
        objectQuery.setResultTransformer(ShowViewResultTransformer.INSTANCE);
        
        ShowResults results = buildResultObject(objectQuery);
        return results;
    }

    private void enableFaceting(QueryBuilder qb, FullTextQuery objectQuery) {
        FacetingRequest categoryFaceting = qb.facet()
            .name("category")
            .onField("event.category.description")
            .discrete()
                .includeZeroCounts(true)
                .orderedBy(FacetSortOrder.FIELD_VALUE)
            .createFacetingRequest();
        FacetingRequest priceFaceting = qb.facet()
            .name("price")
            .onField("ticketPrices.min")
            .range()
                .below(50f).excludeLimit()
                .from(50f).to(100f).excludeLimit()
                .from(100f).to(200f).excludeLimit()
                .above(200f)
                .includeZeroCounts(true)
                .orderedBy(FacetSortOrder.RANGE_DEFINITION_ORDER)
            .createFacetingRequest();
        objectQuery.getFacetManager().enableFaceting(categoryFaceting).enableFaceting(priceFaceting);
    }

    ...
----

=== Return the faceting information

Our next step is to expose the facets to the UI by adding `FacetGroupView` and `FacetView` representations to the returned `ShowResults` and fill these structures with the faceting information provided by Hibernate Search. From an Hibernate Search query, we can access `FacetManager` containing all faceting related information. In particular:

* `FacetManager.getFacets(String)` provides the list of `Facet` for a given group
* `FacetManager.getFacetGroup(String)` offers ways to select / unselect and query selected facets

Our `FacetView` knows whether or not it has been selected. We do compute that state from the `FacetManager`.

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/FacetGroupView.java
----
/** 
 * Represent a facet group exposing its facial name, its identifier
 * and the list of associated facet values.
 * 
 * @author Emmanuel Bernard
 */
public class FacetGroupView {
    private String name;
    private String id;
    private List<FacetView> facets = new ArrayList<FacetView>();
    
    public FacetGroupView(String name, FacetManager fm, String facetingName) {
        this.name = name;
        this.id = facetingName;
        for(Facet facet : fm.getFacets(facetingName)) {
            boolean selected = fm.getFacetGroup(facetingName).getSelectedFacets().contains(facet);
            facets.add(new FacetView(facet, selected));
        }
    }
    
    public String getName() {
        return name;
    }
    
    public List<FacetView> getFacets() {
        return facets;
    }
    
    public void addFacet(FacetView facet) {
        facets.add(facet);
    }
    
    public String getId() {
        return id;
    }
    
    public boolean isWithSelectedFacet() {
        for(FacetView facet : facets) {
            if (facet.isSelected()) {
                return true;
            }
        }
        return false;
    }
}
----

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/FacetView.java
----
/**
 * Represent a facet with its value, the number of matching results and
 * whether or not the user has selected it.
 * 
 * @author Emmanuel Bernard
 */
public class FacetView {
    private String value;
    private int count;
    private boolean selected;
    
    public FacetView(Facet facet, boolean selected) {
        this.value = facet.getValue();
        this.count = facet.getCount();
        this.selected = selected;
    }
    
    public String getValue() {
        return value;
    }
    
    public void overrideValue(String value) {
        this.value = value;
    }

    public int getCount() {
        return count;
    }

    public boolean isSelected() {
        return selected;
    }
}
----

[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
----
    ...

    private ShowResults buildResultObject(FullTextQuery objectQuery) {
        ShowResults results = new ShowResults(objectQuery.getResultList());
        FacetManager fm = objectQuery.getFacetManager();
        FacetGroupView facetGroup = new FacetGroupView("Category", fm, "category");
        results.addFacetGroup(facetGroup);
        facetGroup = new FacetGroupView("Starting price", fm, "price");
        for(int index = 0 ; index < facetGroup.getFacets().size() ; index++) {
            FacetView facet = facetGroup.getFacets().get(index);
            facet.overrideValue(PRICE_FACET_VALUES[index]);
        }
        results.addFacetGroup(facetGroup);
        return results;
    }

    private static String[] PRICE_FACET_VALUES = new String[] {"below $50", "$50 to $100", "$100 to $200", "above $200"};

    ...
----

Since we want to control how price range is displayed in the UI, we have created an array representing the target text (`PRICE_FACET_VALUES`). Expect something integrated in Hibernate Search in the near future.

=== Selecting a facet

To make faceting fully functional, the user needs to be able to select one or several facets. Let's add the ability do pass the selected facets to our REST endpoint and act upon them.


[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
----
    ...

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString, 
        @QueryParam("latitude") Double latitude, @QueryParam("longitude") Double longitude,
        @QueryParam("categoryfacet") Integer categoryFacetId, @QueryParam("minpricefacet") Integer minPriceFacetId) {
        FullTextEntityManager ftem = Search.getFullTextEntityManager(em);
        QueryBuilder qb = ftem.getSearchFactory().buildQueryBuilder().forEntity(Show.class).get();
        
        Query luceneQuery = buildLuceneQuery(searchString, latitude, longitude, qb);
        
        FullTextQuery objectQuery = ftem.createFullTextQuery(luceneQuery, Show.class);
        
        enableFaceting(qb, objectQuery);
        enableFacetRestriction(objectQuery, categoryFacetId, minPriceFacetId);
        
        objectQuery.setResultTransformer(ShowViewResultTransformer.INSTANCE);
        
        ShowResults results = buildResultObject(objectQuery);
        return results;
    }

    ...

    private void enableFacetRestriction(FullTextQuery objectQuery, Integer categoryFacetId, Integer minPriceFacetId) {
        FacetManager fm = objectQuery.getFacetManager();
        if (categoryFacetId != null) {
            Facet selectedFacet = fm.getFacets("category").get(categoryFacetId);
            fm.getFacetGroup("category").selectFacets(selectedFacet);
        }
        if (minPriceFacetId != null) {
            Facet selectedFacet = fm.getFacets("price").get(minPriceFacetId);
            fm.getFacetGroup("price").selectFacets(selectedFacet);
        }
    }

    ...
----

We are done on the backend side. Let's look at `SearchService` in its entirety and move to the UI side.


[source, java]
.src/main/java/org/jboss/jdf/example/ticketmonster/rest/search/SearchService.java
----
/**
 * Service exposed as a REST endpoint and offering full-text search, geolocalized search
 * as well as faceting using Hibernate Search.
 * 
 * @author Emmanuel Bernard
 */
@Stateless
@Path("/search")
public class SearchService {
    @Inject
    EntityManager em;
    @Inject
    Logger logger;

    /**
     * REST endpoint for the search engine
     * 
     * @param searchString contains the words to search
     * @param latitude (optional) search restricted around latitude
     * @param longitude (optional) search restricted around longitude
     * @param categoryFacetId (optional) selected category facet
     * @param minPriceFacetId (optional) selected price facet
     * @return ShowResults containing the results and the faceting data
     */
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public ShowResults search(@QueryParam("query") String searchString, 
        @QueryParam("latitude") Double latitude, @QueryParam("longitude") Double longitude,
        @QueryParam("categoryfacet") Integer categoryFacetId, @QueryParam("minpricefacet") Integer minPriceFacetId) {
        FullTextEntityManager ftem = Search.getFullTextEntityManager(em);
        QueryBuilder qb = ftem.getSearchFactory().buildQueryBuilder().forEntity(Show.class).get();
        
        Query luceneQuery = buildLuceneQuery(searchString, latitude, longitude, qb);
        
        FullTextQuery objectQuery = ftem.createFullTextQuery(luceneQuery, Show.class);
        
        enableFaceting(qb, objectQuery);
        enableFacetRestriction(objectQuery, categoryFacetId, minPriceFacetId);
        
        objectQuery.setResultTransformer(ShowViewResultTransformer.INSTANCE);
        
        ShowResults results = buildResultObject(objectQuery);
        return results;
    }

    private Query buildLuceneQuery(String searchString, Double latitude, Double longitude, QueryBuilder qb) {
        Query luceneQuery;
        Query termsQuery;
        if (searchString.isEmpty()) {
            // Return all terms
            termsQuery = qb.all().createQuery();
        }
        else {
            // Find the terms of searchString with terms in event.name (weight of 10),
            // event.description (weight of 1) and venue.name (weight of 3)
             termsQuery = qb.keyword()
                .onField("event.name").boostedTo(10f)
                .andField("event.description")
                .andField("venue.name").boostedTo(5f)
                .matching(searchString)
                .createQuery();
        }
        if (latitude != null && longitude != null) {
            Query localQuery = qb.spatial()
                .onCoordinates("venue.address.coordinates")
                .within(50, Unit.KM)
                .ofLatitude(latitude).andLongitude(longitude)
                .createQuery();
            luceneQuery = qb.bool()
                .must(termsQuery)
                .must(localQuery)
                .createQuery();
        }
        else {
            luceneQuery = termsQuery;
        }
        return luceneQuery;
    }
    private ShowResults buildResultObject(FullTextQuery objectQuery) {
        ShowResults results = new ShowResults(objectQuery.getResultList());
        FacetManager fm = objectQuery.getFacetManager();
        FacetGroupView facetGroup = new FacetGroupView("Category", fm, "category");
        results.addFacetGroup(facetGroup);
        facetGroup = new FacetGroupView("Starting price", fm, "price");
        for(int index = 0 ; index < facetGroup.getFacets().size() ; index++) {
            FacetView facet = facetGroup.getFacets().get(index);
            facet.overrideValue(PRICE_FACET_VALUES[index]);
        }
        results.addFacetGroup(facetGroup);
        return results;
    }

    private void enableFaceting(QueryBuilder qb, FullTextQuery objectQuery) {
        FacetingRequest categoryFaceting = qb.facet()
            .name("category")
            .onField("event.category.description")
            .discrete()
                .includeZeroCounts(true)
                .orderedBy(FacetSortOrder.FIELD_VALUE)
            .createFacetingRequest();
        FacetingRequest priceFaceting = qb.facet()
            .name("price")
            .onField("ticketPrices.min")
            .range()
                .below(50f).excludeLimit()
                .from(50f).to(100f).excludeLimit()
                .from(100f).to(200f).excludeLimit()
                .above(200f)
                .includeZeroCounts(true)
                .orderedBy(FacetSortOrder.RANGE_DEFINITION_ORDER)
            .createFacetingRequest();
        objectQuery.getFacetManager().enableFaceting(categoryFaceting).enableFaceting(priceFaceting);
    }
    
    private static String[] PRICE_FACET_VALUES = new String[] {"below $50", "$50 to $100", "$100 to $200", "above $200"};

    private void enableFacetRestriction(FullTextQuery objectQuery, Integer categoryFacetId, Integer minPriceFacetId) {
        FacetManager fm = objectQuery.getFacetManager();
        if (categoryFacetId != null) {
            Facet selectedFacet = fm.getFacets("category").get(categoryFacetId);
            fm.getFacetGroup("category").selectFacets(selectedFacet);
        }
        if (minPriceFacetId != null) {
            Facet selectedFacet = fm.getFacets("price").get(minPriceFacetId);
            fm.getFacetGroup("price").selectFacets(selectedFacet);
        }
    }

}
----

=== Exposing faceting to the UI

Integrating faceting and the UI is two-fold:

* display the facets on the query result screen
* re-execute the query if the user has select one or more facets and offer some bookmarkable URL for queries with facet selection

[source,javascript]
.src/main/webapp/resources/js/app/models/results.js
----
        ...

        // the URL with params to reach the REST endpoint
        url: function() {
            params = '?query=' + encodeURIComponent(this.get("query"));
            if (typeof this.get("lat") != 'undefined' && typeof this.get("lng") != 'undefined') {
                params = params + '&latitude=' + encodeURIComponent(this.get("lat")) + '&longitude=' + encodeURIComponent(this.get("lng"));
            }
            if (typeof this.get("category") != 'undefined') {
                params = params + '&categoryfacet=' + this.get("category");
            }
            if (typeof this.get("price") != 'undefined') {
                params = params + '&minpricefacet=' + this.get("price");
            }
            return this.urlRoot + params;
        },

        // the application URL as exposed by the application for bookmarkability
        appUrl: function() {
            result = "search/";
            var query = this.get("query");
            var lat = this.get("lat");
            var lng = this.get("lng");
            var category = this.get("category");
            var minprice = this.get("price");
            if (typeof lat != 'undefined' && typeof lng != 'undefined') {
                result += "around/" + lat + "/" + lng + "/";
            }
            else {
                result += "anywhere/";
            }
            result += encodeURIComponent(query);
            result += "/category/"
            if (typeof category != 'undefined') {
                result += category;
            }
            else {
                result += 'all';
            }
            result += "/minprice/"
            if (typeof minprice != 'undefined') {
                result += minprice;
            }
            else {
                result += 'all';
            }
            return result;
        }

        ...
----

The optionally selected `category` and `price` facet are stored in the model and influence both the REST endpoint URL and the bookmarkable application URL (e.g. `#search/anywhere/morisson/category/all/minprice/1`.

The view needs to react to clicks on the faceting links and properly update the model before navigating to the appropriate URL

[source, javascript]
.src/main/webapp/resources/js/app/views/results.js
----
    ...

    var ResultsView  = Backbone.View.extend({

        events:{
            "click .faceting": "enableFaceting"
        },
        
        initialize:function () {
            this.model.bind('change', this.render, this);
        },
        
        render:function () {
            $(this.el).empty();
            this.delegateEvents();
            utilities.applyTemplate($(this.el), resultsTemplate, {model:this.model, query:this.model.get("query")});
            return this;
        },

        //called when the user clicks on a faceting link and refresh the model and application URL
        enableFaceting:function (e) {
            var id = $(e.currentTarget).data("id");
            var faceting = id.substring(0, id.lastIndexOf('-'));
            var index = id.substring(id.lastIndexOf('-') + 1);
            if (index == 'all') {
                this.model.unset(faceting);
            }
            else {
                this.model.set(faceting, index);
            }
            this.model.fetch();
            this.options.router.navigate(this.model.appUrl());
            return false;
        }

        ...
----

Let's now display the faceting information as a left sidebar. For each facet group we expose the list of facets, their count and add a link triggering the result refresh when a facet is selected (or cleared).

[source, html]
.src/main/webapp/resources/templates/desktop/results.html
----
<h3 class="page-header light-font special-title">Results for <%=query%></h3>
<div class="row-fluid">
    <div class='span3'>
        <div id="itemMenu">
            <% _.each(model.get("facetGroups"), function (facetGroup) { %>
            <div class="facets-group">
                <div class="facets-heading">
                    <a class="facets-toggle"><%=facetGroup.name%></a>
                </div>
                <div class="facets-body in" style="height: auto;">
                    <div class="facets-inner">
                        <%if (facetGroup.withSelectedFacet) { %>
                        <p><a href="#search" class='faceting' data-id='<%=facetGroup.id%>-all'>(Clear)</a></p>
                        <% } %>
                        <% _.each(facetGroup.facets, function (facet, index, facets) { %>
                        <% if (facet.selected == true) { %>
                        <p class='muted'><%=facet.value%> <span class='badge'><%=facet.count%></span></p>
                        <% } else { %>
                        <p><a href="#search" class='faceting' data-id='<%=facetGroup.id%>-<%=index%>'><%=facet.value%> <span class='badge'><%=facet.count%></span></a></p>
                        <% } %>
                        <% }); %>
                    </div>
                </div>
            </div>
            <% }); %>
        </div>
    </div>
    <div class='span9'>
        <table class='table table-bordered' style="background: #fffffa;">
            <thead>
            <tr>
                <th>Event</th>
                <th>Venue</th>
            </tr>
            </thead>
            <tbody id='bookingList'>
            <% _.each(model.get("results"), function (result) { %>
            <tr>
                <td><a href="#events/<%=result.eventId%>"><%=result.eventName%></a></td>
                <td><%=result.venueName%></td>
            </tr>
            <% }); %>
            </tbody>
        </table>
    </div>
</div>
----

Let's finally add the necessary routes corresponding to the facet filtering and update the action methods to update the model with the facets selected.

[source, javascript]
.src/main/webapp/resources/js/app/router/desktop/router.js
----
    ...

    var Router = Backbone.Router.extend({
        routes:{
            ...,
            "search/anywhere/:query":"results",
            "search/anywhere/:query/category/:categoryId/minprice/:priceId":"results",
            "search/around/:lat/:lng/:query":"localResults",
            "search/around/:lat/:lng/:query/category/:categoryId/minprice/:priceId":"localResults",
            ...
        },

        ...,

        results:function (query, categoryId, minPriceId) {
            this.localResults(null, null, query, categoryId, minPriceId);
        },
        localResults:function (lat, lng, query, categoryId, minPriceId) {
            var model = new Results();
            model.set("query", decodeURIComponent(query));
            if (lat != null) {
                model.set("lat", lat);
            }
            if (lng != null) {
                model.set("lng", lng);
            }
            if (typeof(categoryId) != 'undefined' && categoryId != 'all') {
                model.set("category", categoryId);
            }
            if (typeof(minPriceId) != 'undefined' && minPriceId != 'all') {
                model.set("price", minPriceId);
            }
            var resultsView = new ResultsView({model:model, el:$("#content"), router:this});
            model.bind("change",
                function () {
                    utilities.viewManager.showView(resultsView);
                }).fetch();
        }
        
        ...
----

With minimal work, we have added a powerful search engine with geolocalized queries and faceting improve further customer's navigation.

== More resources

To learn more about search and Hibernate Search in particular, take a look at the link:http://search.hibernate.org[Hibernate Search] project and its documentation.
